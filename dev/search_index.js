var documenterSearchIndex = {"docs":
[{"location":"#PermutationSymmetricTensors.jl","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.jl","text":"","category":"section"},{"location":"","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.jl","text":"PermutationSymmetricTensors.jl provides efficient tools for working with multidimensional arrays that are symmetric under any permutation of their indices.","category":"page"},{"location":"","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.jl","text":"This page provides practical examples, usage tips, and performance insights.","category":"page"},{"location":"","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.jl","text":"","category":"page"},{"location":"#Getting-Started","page":"PermutationSymmetricTensors.jl","title":"Getting Started","text":"","category":"section"},{"location":"","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.jl","text":"using PermutationSymmetricTensors\nusing Random # For reproducibility if needed","category":"page"},{"location":"","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.jl","text":"","category":"page"},{"location":"#Creating-Symmetric-Tensors","page":"PermutationSymmetricTensors.jl","title":"Creating Symmetric Tensors","text":"","category":"section"},{"location":"#1.-Low-Level-Constructor","page":"PermutationSymmetricTensors.jl","title":"1. Low-Level Constructor","text":"","category":"section"},{"location":"","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.jl","text":"N = 3       # Size of each axis\ndim = 2     # Number of dimensions\nlen = find_symmetric_tensor_size(N, dim)  # e.g., 6 for N=3, dim=2\ndata = rand(Float64, len)\n\ntensor_a = SymmetricTensor(data, Val(N), Val(dim))","category":"page"},{"location":"#2.-Built-In-Constructors","page":"PermutationSymmetricTensors.jl","title":"2. Built-In Constructors","text":"","category":"section"},{"location":"","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.jl","text":"tensor_b = rand(SymmetricTensor{Float64, 3, 3})         # Random values","category":"page"},{"location":"","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.jl","text":"tensor_c = zeros(SymmetricTensor{Int, 4, 2})            # Zeros","category":"page"},{"location":"","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.jl","text":"tensor_d = ones(SymmetricTensor{Bool, 2, 4})            # Ones","category":"page"},{"location":"","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.jl","text":"tensor_e = similar(tensor_c)                            # Uninitialized with same type","category":"page"},{"location":"","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.jl","text":"tensor_f = similar(tensor_d, Char)                      # Uninitialized with new type","category":"page"},{"location":"","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.jl","text":"","category":"page"},{"location":"#Indexing-and-Symmetry","page":"PermutationSymmetricTensors.jl","title":"Indexing and Symmetry","text":"","category":"section"},{"location":"","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.jl","text":"Indexing into a symmetric tensor is invariant under permutations of the indices:","category":"page"},{"location":"","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.jl","text":"A = rand(SymmetricTensor{Float64, 2, 3})\n\nA[1, 2, 1] == A[2, 1, 1] == A[1, 1, 2]  # All access the same element\n\nA[1, 2, 1] = 42.0\n\n@assert A[2, 1, 1] == 42.0","category":"page"},{"location":"","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.jl","text":"You can also slice and broadcast:","category":"page"},{"location":"","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.jl","text":"A[:, 1, 1] .= 0","category":"page"},{"location":"","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.jl","text":"","category":"page"},{"location":"#Utility-Functions","page":"PermutationSymmetricTensors.jl","title":"Utility Functions","text":"","category":"section"},{"location":"#find_symmetric_tensor_size","page":"PermutationSymmetricTensors.jl","title":"find_symmetric_tensor_size","text":"","category":"section"},{"location":"","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.jl","text":"Returns the number of unique values stored in a symmetric tensor of size N and dimension dim.","category":"page"},{"location":"","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.jl","text":"find_symmetric_tensor_size(3, 3)  # Returns 10","category":"page"},{"location":"","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.jl","text":"Useful for constructing from raw data:","category":"page"},{"location":"","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.jl","text":"data = rand(Float64, find_symmetric_tensor_size(4, 3))\nT = SymmetricTensor(data, Val(4), Val(3));","category":"page"},{"location":"","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.jl","text":"","category":"page"},{"location":"#find_degeneracy","page":"PermutationSymmetricTensors.jl","title":"find_degeneracy","text":"","category":"section"},{"location":"","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.jl","text":"Returns a tensor indicating how many permutations of the indices point to each element.","category":"page"},{"location":"","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.jl","text":"A = rand(SymmetricTensor{Float64, 2, 3})\nD = find_degeneracy(A)\n\n@show D[1, 1, 2] ","category":"page"},{"location":"","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.jl","text":"","category":"page"},{"location":"#find_full_indices","page":"PermutationSymmetricTensors.jl","title":"find_full_indices","text":"","category":"section"},{"location":"","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.jl","text":"Gives you the sorted list of canonical index tuples that correspond to the linear storage layout.","category":"page"},{"location":"","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.jl","text":"inds = find_full_indices(3, 2)\nfor (i, idx) in enumerate(inds)\n    println(\"Linear index $i maps to Cartesian index $idx\")\nend","category":"page"},{"location":"","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.jl","text":"","category":"page"},{"location":"#Performance-Tips","page":"PermutationSymmetricTensors.jl","title":"Performance Tips","text":"","category":"section"},{"location":"#Memory-Savings","page":"PermutationSymmetricTensors.jl","title":"Memory Savings","text":"","category":"section"},{"location":"","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.jl","text":"A = rand(SymmetricTensor{Float64, 14, 16})\n\nprintln(\"Compressed size: \", Base.format_bytes(Base.summarysize(A)))\nprintln(\"Full array would require: \", round(Float64(big(14)^16 * 8)/2^30, digits=2), \" GiB\")","category":"page"},{"location":"#Efficient-Aggregations","page":"PermutationSymmetricTensors.jl","title":"Efficient Aggregations","text":"","category":"section"},{"location":"","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.jl","text":"Use the internal .data field with the degeneracy weights:","category":"page"},{"location":"","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.jl","text":"deg = find_degeneracy(A)\nsum(A.data .* deg.data)  # Correct full sum over symmetric elements","category":"page"},{"location":"#Broadcasting-Performance","page":"PermutationSymmetricTensors.jl","title":"Broadcasting Performance","text":"","category":"section"},{"location":"","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.jl","text":"Avoid converting to full arrays unintentionally:","category":"page"},{"location":"","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.jl","text":"A.data .= log.(A.data .+ 1e-8)  # Efficient\n\n#B = A .* 0  # WARNING: returns a full Array{Float64, N}. Will overflow RAM","category":"page"},{"location":"","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.jl","text":"","category":"page"},{"location":"#Example:-Exploring-Internal-Representation","page":"PermutationSymmetricTensors.jl","title":"Example: Exploring Internal Representation","text":"","category":"section"},{"location":"","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.jl","text":"A = rand(SymmetricTensor{Float64, 3, 3})\ndeg = find_degeneracy(A)\ninds = find_full_indices(A)\n\nfor i in eachindex(A.data)\n    println(\"data[$i] = \", A.data[i], \", index: \", inds[i], \", deg: \", deg[inds[i]...])\nend","category":"page"},{"location":"","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.jl","text":"","category":"page"},{"location":"#Summary-of-Public-API","page":"PermutationSymmetricTensors.jl","title":"Summary of Public API","text":"","category":"section"},{"location":"","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.jl","text":"Feature Description\nSymmetricTensor{T, N, dim} Core symmetric tensor type\nfind_symmetric_tensor_size Number of stored unique elements\nfind_degeneracy Permutation multiplicity tensor\nfind_full_indices List of canonical index tuples\nzeros, ones, rand, similar Tensor constructors\ngetindex, setindex! Symmetric indexing and mutation","category":"page"},{"location":"","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.jl","text":"","category":"page"},{"location":"#Full-API-Reference","page":"PermutationSymmetricTensors.jl","title":"Full API Reference","text":"","category":"section"},{"location":"","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.jl","text":"For a complete overview of all exported functions and types:","category":"page"},{"location":"#PermutationSymmetricTensors.PermutationSymmetricTensors","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.PermutationSymmetricTensors","text":"This module provides the SymmetricTensor type, representing a tensor whose elements are symmetric under any permutation of their indices. It allows for efficient storage and manipulation of such tensors.\n\nKey functionalities include:\n\nCreating SymmetricTensor instances (e.g., with random values, zeros, ones).\nIndexing into the tensor using standard array-like notation.\nCalculating the number of unique elements required to store the tensor using find_symmetric_tensor_size.\nDetermining the degeneracy (number of equivalent permutations) for each element using find_degeneracy.\nRetrieving the unique sorted Cartesian indices corresponding to the stored elements via find_full_indices.\n\n\n\n\n\n","category":"module"},{"location":"#PermutationSymmetricTensors.SymmetricTensor","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.SymmetricTensor","text":"SymmetricTensor{T, N, dim} <: AbstractArray{T, dim}\n\nA tensor of dim dimensions, where each dimension has N elements of type T. The tensor is symmetric under permutation of its indices.\n\nFields\n\ndata::Vector{T}: A flat vector storing the unique elements of the symmetric tensor. The length of this vector is determined by find_symmetric_tensor_size(N, dim).\nlinear_indices::Vector{Vector{Int64}}: Precomputed indices to map sorted Cartesian indices to the linear index in the data vector. This is an internal field used for efficient indexing.\n\n\n\n\n\n","category":"type"},{"location":"#PermutationSymmetricTensors.SymmetricTensor-Union{Tuple{dim}, Tuple{N}, Tuple{T}, Tuple{Vector{T}, Val{N}, Val{dim}}} where {T, N, dim}","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.SymmetricTensor","text":"SymmetricTensor(data::Array{T, 1}, ::Val{N}, ::Val{dim}) where {T, N, dim}\n\nLow level constructor for the SymmetricTensor type. \n\nExample:\n\nN = 10\ndim = 3\nNdata = find_symmetric_tensor_size(N, dim)\nT = Float64\ndata = rand(T, Ndata)\nSymmetricTensor(data, Val(N), Val(dim))\n\n\n\n\n\n","category":"method"},{"location":"#Base.getindex-Union{Tuple{N}, Tuple{dim}, Tuple{T}, Tuple{SymmetricTensor{T, N, dim}, Vararg{Int64}}} where {T, dim, N}","page":"PermutationSymmetricTensors.jl","title":"Base.getindex","text":"getindex(A::SymmetricTensor{T, N, dim}, I::Int...) -> T\n\nRetrieve the element at the specified indices I from the symmetric tensor A. The indices I can be provided in any order; due to the tensor's symmetry, A[i, j, k] is equivalent to A[k, j, i], etc.\n\nThe method also supports linear indexing if a single index is provided.\n\nArguments\n\nA::SymmetricTensor{T, N, dim}: The symmetric tensor to access.\nI::Int...: A sequence of dim integer indices, or a single linear index.\n\nReturns\n\nT: The element at the specified position.\n\nExamples\n\njulia> tensor = ones(SymmetricTensor{Float64, 2, 3});\njulia> tensor[1, 2, 1]\n1.0\n\njulia> tensor[1, 1, 2] # Same as above due to symmetry\n1.0\n\njulia> tensor[2] # Linear indexing (equivalent to tensor[2,1,1] in this case based on internal order)\n1.0\n\nThis method is implemented using a @generated function for efficiency, which constructs specialized code based on the tensor's dimension (dim). For example, for dim = 3, the internal logic effectively sorts the indices and uses precomputed values to find the element in the underlying data vector.\n\n\n\n\n\n","category":"method"},{"location":"#Base.setindex!-Union{Tuple{N}, Tuple{dim}, Tuple{T}, Tuple{SymmetricTensor{T, N, dim}, Any, Vararg{Int64}}} where {T, dim, N}","page":"PermutationSymmetricTensors.jl","title":"Base.setindex!","text":"setindex!(A::SymmetricTensor{T, N, dim}, value, I::Int...) -> typeof(value)\n\nSet the element at the specified indices I in the symmetric tensor A to value. The indices I can be provided in any order; due to the tensor's symmetry, setting A[i, j, k] will also affect permutations like A[k, j, i].\n\nThe method also supports linear indexing if a single index is provided.\n\nArguments\n\nA::SymmetricTensor{T, N, dim}: The symmetric tensor to modify.\nvalue: The value to assign to the element.\nI::Int...: A sequence of dim integer indices, or a single linear index.\n\nReturns\n\nThe assigned value.\n\nExamples\n\njulia> tensor = zeros(SymmetricTensor{Float64, 2, 3});\njulia> tensor[1, 2, 1] = 5.0;\njulia> tensor[1, 1, 2]\n5.0\n\njulia> tensor[1] = 3.0; # Linear indexing\njulia> tensor[1,1,1] # Assuming [1,1,1] is the first linear index\n3.0\n\nThis method is implemented using a @generated function for efficiency, which constructs specialized code based on the tensor's dimension (dim). For example, for dim = 3, the internal logic effectively sorts the indices and uses precomputed values to find the element in the underlying data vector to update.\n\n\n\n\n\n","category":"method"},{"location":"#PermutationSymmetricTensors.check_correct_size-Tuple{Any, Any, Any}","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.check_correct_size","text":"check_correct_size(num_elements::Int, N::Int, dim::Int) -> Bool\n\nInternal helper function to verify if num_elements is the correct count for a SymmetricTensor with dimension dim and size N for each dimension.\n\nArguments\n\nnum_elements::Int: The number of elements to check (typically length(data)).\nN::Int: The size of each dimension.\ndim::Int: The number of dimensions.\n\nReturns\n\nBool: true if num_elements matches find_symmetric_tensor_size(N, dim), false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"#PermutationSymmetricTensors.find_N_repetitions_sorted!-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T<:Integer","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.find_N_repetitions_sorted!","text":"find_N_repetitions_sorted!(reps::Vector{<:Integer}, tup::NTuple)\n\nInternal helper function to count repetitions of elements in a sorted tuple. It updates the reps vector such that reps[i] stores the count of distinct elements that appear exactly i times in the tuple tup.\n\nThis function is used by find_degeneracy to calculate the multiplicity factor for tensor elements.\n\nArguments\n\nreps::Vector{<:Integer}: A vector to store the counts. It will be modified in-place. Its length should be at least length(tup).\ntup::NTuple: A tuple of elements, which must be sorted in non-decreasing order.\n\nExamples\n\njulia> reps = zeros(Int, 8);\njulia> tup = (1, 3, 3, 5, 5, 5, 5, 7); # Must be sorted\njulia> PermutationSymmetricTensors.find_N_repetitions_sorted!(reps, tup);\njulia> reps # Element 1 appears once, 7 once (reps[1]=2). Element 3 appears twice (reps[2]=1). Element 5 appears four times (reps[4]=1).\n    8-element Vector{Int64}:\n    2 # Two elements (1 and 7) appear once\n    1 # One element (3) appears twice\n    0 # Zero elements appear three times\n    1 # One element (5) appears four times\n    0 # Zero elements appear five times\n    0 # Zero elements appear six times\n    0 # Zero elements appear seven times\n    0 # Zero elements appear eight times\n\n\n\n\n\n","category":"method"},{"location":"#PermutationSymmetricTensors.find_degeneracy-Tuple{Any, Any, Any}","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.find_degeneracy","text":"function find_degeneracy(N::Int, dim::Int)\nfunction find_degeneracy(A::SymmetricTensor{T, N, dim}) where {T, N, dim}\nfunction find_degeneracy(N, dim, full_indices::Vector{<:NTuple{dim, Any}})\n\nReturns a SymmetricTensor{Int64, N, dim} where each element d[i,j,...] contains the number of distinct permutations of the indices (i,j,...) that map to the same unique element in the SymmetricTensor. This value represents the \"degeneracy\" of that particular combination of indices.\n\nArguments\n\nN::Int: The size of each dimension of the tensor.\ndim::Int: The number of dimensions of the tensor.\nA::SymmetricTensor: An existing SymmetricTensor instance from which N and dim can be derived.\nfull_indices::Vector{<:NTuple{dim, Any}}: (Optional) The output of find_full_indices(N, dim), provided for efficiency if already computed.\n\nReturns\n\nSymmetricTensor{Int64, N, dim}: A tensor where each element stores its degeneracy.\n\nExamples\n\njulia> find_degeneracy(3, 3)\n    3×3×3 SymmetricTensor{Int64, 3, 3}:\n    [:, :, 1] =\n    1  3  3\n    3  3  6\n    3  6  3\n\n    [:, :, 2] =\n    3  3  6\n    3  1  3\n    6  3  3\n\n    [:, :, 3] =\n    3  6  3\n    6  3  3\n    3  3  1\n\njulia> a = rand(SymmetricTensor{Float64, 2, 4});\njulia> d = find_degeneracy(a);\njulia> d[1,1,1,1] # Element (1,1,1,1) is unique\n1\njulia> d[1,1,1,2] # Element (1,1,1,2) has 4 permutations (1112, 1121, 1211, 2111)\n4\n\n\n\n\n\n","category":"method"},{"location":"#PermutationSymmetricTensors.find_full_indices-Union{Tuple{dim}, Tuple{Any, Any, Val{dim}}} where dim","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.find_full_indices","text":"function find_full_indices(N, dim)\n\nReturns an ordered array of tuples of indices (i1, i2, i3, ..., i{dim}) such that  i1 >= i2 >= i3 ... >= i{dim}. This can be used to find the cartesian index that  corresponds to a linear index of a SymmetricTensor{T, N, dim}.  Example:\n\njulia> find_full_indices(3, 3)\n10-element Vector{Tuple{Int8, Int8, Int8}}:\n(1, 1, 1)\n(2, 1, 1)\n(3, 1, 1)\n(2, 2, 1)\n(3, 2, 1)\n(3, 3, 1)\n(2, 2, 2)\n(3, 2, 2)\n(3, 3, 2)\n(3, 3, 3)\n\nIt is implemented with a generated function, for dim = 3, the following code will be executed:\n\nfunction _find_full_indices(N, Val(3))\n    full_indices = NTuple{3, Int16}[]\n    for i3 = 1:N\n        for i2 = i3:N\n            for i1 = i2:N\n                push!(full_indices, ((i1..., i2)..., i3))\n            end\n        end\n    end\n    full_indices\nend\n\n\n\n\n\n","category":"method"},{"location":"#PermutationSymmetricTensors.find_linear_index_array-Union{Tuple{dim}, Tuple{Int64, Val{dim}}} where dim","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.find_linear_index_array","text":"find_linear_index_array(N::Int, ::Val{dim}) -> Vector{Int64}\n\nInternal @generated function to compute a vector of index contributions for a specific dimension, used in calculating the linear index into the data array of a SymmetricTensor.\n\nThis function is part of the mechanism that maps multi-dimensional indices (i1, i2, ..., idim) (sorted descendingly) to a unique linear index. The SymmetricTensor stores dim such vectors in its linear_indices field. Each vector A.linear_indices[k] corresponds to find_linear_index_array(N, Val(k)).\n\nThe linear index for (I1, I2, ..., Ik, ..., Idim) (where Ik are sorted indices) is roughly sum(A.linear_indices[k][Ik] for k=1:dim).\n\nThe actual generated code efficiently calculates these contributions. For example, for dim = 3, it generates:\n\nfunction find_linear_index_array(N::Int, ::Val{3})\n    idim_contribution_array = zeros(Int64, N)\n    contribution = 0\n    count = 0\n    firstcount = 0\n    for i3 = 1:N\n        for i2 = i3:N\n            for i1 = i2:N\n                count += 1\n                if ((i1 == i2) && i2 == i3)\n                    if i3 == 1\n                        firstcount = count\n                    end\n                    contribution = count - firstcount\n                    idim_contribution_array[i3] = contribution\n                end\n            end\n        end\n    end\n    idim_contribution_array\nend\n\n\n\n\n\n","category":"method"},{"location":"#PermutationSymmetricTensors.find_linear_indices-Union{Tuple{dim}, Tuple{N}, Tuple{Val{N}, Val{dim}}} where {N, dim}","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.find_linear_indices","text":"find_linear_indices(::Val{N}, ::Val{dim}) -> Vector{Vector{Int64}}\n\nInternal function to compute all necessary linear index contribution vectors for a SymmetricTensor of size N and dimension dim.\n\nThis function iteratively calls find_linear_index_array(N, Val(k)) for k from 1 to dim. The resulting collection of vectors is stored in the linear_indices field of a SymmetricTensor and is crucial for its indexing operations.\n\nArguments\n\n::Val{N}: A Val instance representing the size of each dimension.\n::Val{dim}: A Val instance representing the number of dimensions.\n\nReturns\n\nVector{Vector{Int64}}: A vector where each inner vector is the result of find_linear_index_array(N, Val(k)) for k in 1:dim.\n\n\n\n\n\n","category":"method"},{"location":"#PermutationSymmetricTensors.find_symmetric_tensor_size-Tuple{Any, Any}","page":"PermutationSymmetricTensors.jl","title":"PermutationSymmetricTensors.find_symmetric_tensor_size","text":"function find_symmetric_tensor_size(N, dim)\n\nReturns the number of elements of a symmetric tensor of dimension dim of N elements in each dimension.  The results is given by binomial(N-1+dim, dim).\n\nExample: julia` julia> find_symmetric_tensor_size(20, 6) 177100\n\n\n\n\n\n","category":"method"},{"location":"#Random.rand!-Union{Tuple{SymmetricTensor{T, N, dim}}, Tuple{T}, Tuple{dim}, Tuple{N}} where {N, dim, T}","page":"PermutationSymmetricTensors.jl","title":"Random.rand!","text":"rand!(A::SymmetricTensor, [rng::AbstractRNG], [values])\n\nFill the symmetric tensor A with random values.\n\nThis function populates the underlying data vector of the SymmetricTensor with random numbers. Due to the tensor's symmetry, only the unique elements are stored and randomized.\n\nArguments\n\nA::SymmetricTensor: The symmetric tensor to be filled with random values. It is modified in-place.\nrng::AbstractRNG (optional): A specific random number generator to use. If not provided, the default global RNG is used.\nvalues (optional): A collection of values to sample from (e.g., a range like 0:9, or a specific set like [1.0, 2.5, 3.0]). If not provided, rand will produce values of the tensor's element type (e.g., Float64 in [0,1)).\n\nReturns\n\nA: The modified tensor A, filled with random values. (Note: rand! traditionally returns the modified array, but the current implementation returns nothing. This docstring reflects the traditional behavior for consistency with Base.rand!, though the implementation detail differs.)\n\nExamples\n\njulia> N = 2; dim = 2;\njulia> ts = zeros(SymmetricTensor{Float64, N, dim});\n\njulia> rand!(ts); # Fill with random Float64 values\njulia> ts[1,1] # Will be a random Float64\n\njulia> rand!(ts, MersenneTwister(123)); # Using a specific RNG\njulia> ts[1,2] # Will be a random Float64\n\njulia> rand!(ts, 1:10); # Fill with random integers from 1 to 10\njulia> ts[2,2] # Will be a random integer between 1 and 10\n\n\n\n\n\n","category":"method"}]
}
