var documenterSearchIndex = {"docs":
[{"location":"#PermutationSymmetricTensors.jl","page":"Home","title":"PermutationSymmetricTensors.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"@meta CurrentModule = PermutationSymmetricTensors","category":"page"},{"location":"#Example-Usage","page":"Home","title":"Example Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This section provides practical examples of how to use PermutationSymmetricTensors.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"First, let's bring the module into scope:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PermutationSymmetricTensors\nusing Random # For seeding, if desired","category":"page"},{"location":"#Creating-a-SymmetricTensor","page":"Home","title":"Creating a SymmetricTensor","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are several ways to construct a SymmetricTensor.","category":"page"},{"location":"","page":"Home","title":"Home","text":"1. Using the low-level constructor with explicit data:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Define dimensions and size\nN = 3 # Size of each dimension (e.g., indices from 1 to 3)\ndim = 2 # Number of dimensions\n\n# Calculate the required number of unique elements\nlen_data = find_symmetric_tensor_size(N, dim) # For N=3, dim=2, this is 6\n\n# Create some data (e.g., random)\nRandom.seed!(123) # for reproducibility\ndata_vector = rand(Float64, len_data)\n\n# Construct the tensor\ntensor_a = SymmetricTensor(data_vector, Val(N), Val(dim))\nprintln(\"Tensor A (from data_vector):\")\ndisplay(tensor_a)\nprintln(\"\\\\n\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"2. Using rand for random initialization:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Create a 2x2x2 tensor with Float64 elements, random values in [0,1)\ntensor_b = rand(SymmetricTensor{Float64, 2, 3})\nprintln(\"Tensor B (randomly initialized):\")\ndisplay(tensor_b)\nprintln(\"\\\\n\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"3. Using zeros for zero initialization:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Create a 2x2 tensor with Int elements, initialized to zero\ntensor_c = zeros(SymmetricTensor{Int, 2, 2})\nprintln(\"Tensor C (zero-initialized):\")\ndisplay(tensor_c)\nprintln(\"\\\\n\")","category":"page"},{"location":"#Getting-and-Setting-Elements","page":"Home","title":"Getting and Setting Elements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Elements are accessed using standard indexing. Due to symmetry, the order of indices does not matter.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Using tensor_b from above (2x2x2 Float64 tensor)\nprintln(\"Original tensor_b[1,2,1]: \", tensor_b[1,2,1])\n\n# Set an element\ntensor_b[1,2,1] = 0.5\nprintln(\"After tensor_b[1,2,1] = 0.5:\")\nprintln(\"tensor_b[1,2,1]: \", tensor_b[1,2,1])\nprintln(\"tensor_b[2,1,1] (should be same): \", tensor_b[2,1,1]) # Permuted index\nprintln(\"tensor_b[1,1,2] (should be same): \", tensor_b[1,1,2]) # Permuted index\nprintln(\"\\\\n\")\n\n# Modifying tensor_c\ntensor_c[1,2] = 5\nprintln(\"Tensor C after tensor_c[1,2] = 5:\")\ndisplay(tensor_c)\nprintln(\"tensor_c[2,1] (should be same): \", tensor_c[2,1])\nprintln(\"\\\\n\")","category":"page"},{"location":"#Using-Utility-Functions","page":"Home","title":"Using Utility Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"1. find_symmetric_tensor_size: Calculate the number of unique elements required for a symmetric tensor.","category":"page"},{"location":"","page":"Home","title":"Home","text":"N_val = 4\ndim_val = 3\nnum_elements = find_symmetric_tensor_size(N_val, dim_val)\nprintln(\"Number of unique elements for a $N_val^$dim_val symmetric tensor: \", num_elements) # Binomial(4+3-1, 3) = 20\nprintln(\"\\\\n\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"2. find_degeneracy: Get a tensor where each element shows how many permutations of its indices map to it.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Using tensor_c (2x2 Int tensor)\ndegeneracy_c = find_degeneracy(tensor_c)\nprintln(\"Degeneracy tensor for Tensor C (2x2):\")\ndisplay(degeneracy_c)\n# For a 2x2 tensor:\n# d[1,1] = 1 (only 1,1)\n# d[1,2] = 2 (1,2 and 2,1)\n# d[2,1] is same as d[1,2]\n# d[2,2] = 1 (only 2,2)\nprintln(\"\\\\n\")\n\ndegeneracy_b = find_degeneracy(SymmetricTensor{Int, 2, 3}) # For a generic 2x2x2 shape\nprintln(\"Degeneracy for a 2x2x2 tensor shape:\")\ndisplay(degeneracy_b)\n# For a 2x2x2 tensor:\n# d[1,1,1] = 1\n# d[1,1,2] = 3 (112, 121, 211)\n# d[1,2,2] = 3 (122, 212, 221)\n# d[2,2,2] = 1\nprintln(\"\\\\n\")\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"3. find_full_indices: Get the list of unique Cartesian indices corresponding to the linear storage. The indices are sorted such that i1 >= i2 >= ... >= idim.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# For a 3x3 tensor (N=3, dim=2)\nfull_idx_3_2 = find_full_indices(3, 2)\nprintln(\"Full indices for N=3, dim=2 (sorted i1>=i2):\")\nfor (i, idx) in enumerate(full_idx_3_2)\n    println(\"Linear index $i maps to Cartesian index $idx\")\nend\n# Expected order for N=3, dim=2: (1,1), (2,1), (2,2), (3,1), (3,2), (3,3)\n# Let's re-verify against the code's logic:\n# The @generated function for find_full_indices (T, N, ::Val{dim}) has nested loops:\n# for i_dim = start_outer:N ... for i_1 = start_inner:N.\n# For dim=2, (i1, i2): for i2 = 1:N; for i1 = i2:N; push!((i1,i2)).\n# So for N=3, dim=2:\n# i2=1: i1=1 -> (1,1)\n#       i1=2 -> (2,1)\n#       i1=3 -> (3,1)\n# i2=2: i1=2 -> (2,2)\n#       i1=3 -> (3,2)\n# i2=3: i1=3 -> (3,3)\n# Output: (1,1), (2,1), (3,1), (2,2), (3,2), (3,3)\nprintln(\"\\\\n\")\n\n# Example: Relating to tensor_a (N=3, dim=2)\nprintln(\"tensor_a was created with N=3, dim=2. Its data has length: \", length(tensor_a.data))\nprintln(\"The first element tensor_a.data[1] corresponds to Cartesian index: \", full_idx_3_2[1]) # Should be (1,1)\nprintln(\"The fourth element tensor_a.data[4] corresponds to Cartesian index: \", full_idx_3_2[4]) # Should be (2,2)\nprintln(\"\\\\n\")","category":"page"},{"location":"#Public-API","page":"Home","title":"Public API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This section highlights the core functionalities and types provided by the PermutationSymmetricTensors.jl package, serving as a quick reference to its main features.","category":"page"},{"location":"#Full-API-Reference","page":"Home","title":"Full API Reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A complete list of all exported names from the PermutationSymmetricTensors module. This provides a comprehensive overview of all functionalities available to users.","category":"page"},{"location":"#PermutationSymmetricTensors.PermutationSymmetricTensors","page":"Home","title":"PermutationSymmetricTensors.PermutationSymmetricTensors","text":"This module provides the SymmetricTensor type, representing a tensor whose elements are symmetric under any permutation of their indices. It allows for efficient storage and manipulation of such tensors.\n\nKey functionalities include:\n\nCreating SymmetricTensor instances (e.g., with random values, zeros, ones).\nIndexing into the tensor using standard array-like notation.\nCalculating the number of unique elements required to store the tensor using find_symmetric_tensor_size.\nDetermining the degeneracy (number of equivalent permutations) for each element using find_degeneracy.\nRetrieving the unique sorted Cartesian indices corresponding to the stored elements via find_full_indices.\n\n\n\n\n\n","category":"module"},{"location":"#PermutationSymmetricTensors.SymmetricTensor","page":"Home","title":"PermutationSymmetricTensors.SymmetricTensor","text":"SymmetricTensor{T, N, dim} <: AbstractArray{T, dim} \n\nA tensor of dim dimensions, where each dimension has N elements of type T. The tensor is symmetric under permutation of its indices.\n\nFields\n\ndata::Vector{T}: A flat vector storing the unique elements of the symmetric tensor. The length of this vector is determined by find_symmetric_tensor_size(N, dim).\nlinear_indices::Vector{Vector{Int64}}: Precomputed indices to map sorted Cartesian indices to the linear index in the data vector. This is an internal field used for efficient indexing.\n\n\n\n\n\n","category":"type"},{"location":"#PermutationSymmetricTensors.SymmetricTensor-Union{Tuple{dim}, Tuple{N}, Tuple{T}, Tuple{Vector{T}, Val{N}, Val{dim}}} where {T, N, dim}","page":"Home","title":"PermutationSymmetricTensors.SymmetricTensor","text":"SymmetricTensor(data::Array{T, 1}, ::Val{N}, ::Val{dim}) where {T, N, dim}\n\nLow level constructor for the SymmetricTensor type. \n\nExample:\n\nN = 10\ndim = 3\nNdata = find_symmetric_tensor_size(N, dim)\nT = Float64\ndata = rand(T, Ndata)\nSymmetricTensor(data, Val(N), Val(dim))\n\n\n\n\n\n","category":"method"},{"location":"#PermutationSymmetricTensors.find_degeneracy-Tuple{Any, Any, Any}","page":"Home","title":"PermutationSymmetricTensors.find_degeneracy","text":"function finddegeneracy(N::Int, dim::Int) function finddegeneracy(A::SymmetricTensor{T, N, dim}) where {T, N, dim} function finddegeneracy(N, dim, fullindices::Vector{<:NTuple{dim, Any}})\n\nReturns a SymmetricTensor{Int64, N, dim} where each element d[i,j,...] contains the number of distinct permutations of the indices (i,j,...) that map to the same unique element in the SymmetricTensor. This value represents the \"degeneracy\" of that particular combination of indices.\n\nArguments\n\nN::Int: The size of each dimension of the tensor.\ndim::Int: The number of dimensions of the tensor.\nA::SymmetricTensor: An existing SymmetricTensor instance from which N and dim can be derived.\nfull_indices::Vector{<:NTuple{dim, Any}}: (Optional) The output of find_full_indices(N, dim), provided for efficiency if already computed.\n\nReturns\n\nSymmetricTensor{Int64, N, dim}: A tensor where each element stores its degeneracy.\n\nExamples\n\njulia> find_degeneracy(3, 3)\n    3×3×3 SymmetricTensor{Int64, 3, 3}:\n    [:, :, 1] =\n    1  3  3\n    3  3  6\n    3  6  3\n\n    [:, :, 2] =\n    3  3  6\n    3  1  3\n    6  3  3\n\n    [:, :, 3] =\n    3  6  3\n    6  3  3\n    3  3  1\n\njulia> a = rand(SymmetricTensor{Float64, 2, 4});\njulia> d = find_degeneracy(a);\njulia> d[1,1,1,1] # Element (1,1,1,1) is unique\n1\njulia> d[1,1,1,2] # Element (1,1,1,2) has 4 permutations (1112, 1121, 1211, 2111)\n4\n\n\n\n\n\n","category":"method"},{"location":"#PermutationSymmetricTensors.find_full_indices-Union{Tuple{dim}, Tuple{Any, Any, Val{dim}}} where dim","page":"Home","title":"PermutationSymmetricTensors.find_full_indices","text":"function findfullindices(N, dim)\n\nReturns an ordered array of tuples of indices (i1, i2, i3, ..., i{dim}) such that \ni1 >= i2 >= i3 ... >= i{dim}. This can be used to find the cartesian index that \ncorresponds to a linear index of a SymmetricTensor{T, N, dim}. \nExample:\njulia> find_full_indices(3, 3)\n10-element Vector{Tuple{Int8, Int8, Int8}}:\n(1, 1, 1)\n(2, 1, 1)\n(3, 1, 1)\n(2, 2, 1)\n(3, 2, 1)\n(3, 3, 1)\n(2, 2, 2)\n(3, 2, 2)\n(3, 3, 2)\n(3, 3, 3)\n\nIt is implemented with a generated function, for dim = 3, the following code will be executed:\nfunction _find_full_indices(N, Val(3))\n    full_indices = NTuple{3, Int16}[]\n    for i3 = 1:N\n        for i2 = i3:N\n            for i1 = i2:N\n                push!(full_indices, ((i1..., i2)..., i3))\n            end\n        end\n    end\n    full_indices\nend\n\n\n\n\n\n","category":"method"},{"location":"#PermutationSymmetricTensors.find_symmetric_tensor_size-Tuple{Any, Any}","page":"Home","title":"PermutationSymmetricTensors.find_symmetric_tensor_size","text":"function findsymmetrictensor_size(N, dim)\n\nReturns the number of elements of a symmetric tensor of dimension dim of N elements in each dimension. \nThe results is given by binomial(N-1+dim, dim).\n\nExample:\njulia> find_symmetric_tensor_size(20, 6)\n177100\n\n\n\n\n\n","category":"method"},{"location":"#Random.rand!-Union{Tuple{SymmetricTensor{T, N, dim}}, Tuple{T}, Tuple{dim}, Tuple{N}} where {N, dim, T}","page":"Home","title":"Random.rand!","text":"rand!(A::SymmetricTensor, [rng::AbstractRNG], [values])\n\nFill the symmetric tensor A with random values.\n\nThis function populates the underlying data vector of the SymmetricTensor with random numbers. Due to the tensor's symmetry, only the unique elements are stored and randomized.\n\nArguments\n\nA::SymmetricTensor: The symmetric tensor to be filled with random values. It is modified in-place.\nrng::AbstractRNG (optional): A specific random number generator to use. If not provided, the default global RNG is used.\nvalues (optional): A collection of values to sample from (e.g., a range like 0:9, or a specific set like [1.0, 2.5, 3.0]). If not provided, rand will produce values of the tensor's element type (e.g., Float64 in [0,1)).\n\nReturns\n\nA: The modified tensor A, filled with random values. (Note: rand! traditionally returns the modified array, but the current implementation returns nothing. This docstring reflects the traditional behavior for consistency with Base.rand!, though the implementation detail differs.)\n\nExamples\n\njulia> N = 2; dim = 2;\njulia> ts = zeros(SymmetricTensor{Float64, N, dim});\n\njulia> rand!(ts); # Fill with random Float64 values\njulia> ts[1,1] # Will be a random Float64\n\njulia> rand!(ts, MersenneTwister(123)); # Using a specific RNG\njulia> ts[1,2] # Will be a random Float64\n\njulia> rand!(ts, 1:10); # Fill with random integers from 1 to 10\njulia> ts[2,2] # Will be a random integer between 1 and 10\n\n\n\n\n\n","category":"method"}]
}
